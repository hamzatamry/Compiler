******************************************************************************
Tools punctuations      ~ ! @ # * ( ) _ + ' ;
******************************************************************************
&&        &&
?     ?
||            ||
,                 ,
:             :
=                    =
{        {
} 	    }

++               ++  
/                    /  
%             %
--               --    
-              -  
id_pattern              [a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])? 
string_pattern          [ a-zA-Z0-9_;:!,?\|[](]&~^$µeè@à` ]*
number_pattern          [0-9]+ 
comparator              (>, >=, <, <=, ==, ===, !=)
symbole_aff             =, <-, :=

*********************************************************************************************

INSTRUCTIONS            ->	{ INSTRUCTION INSTRUCTIONS }
                        |	INSTRUCTION FINSTRUCTION .

FINSTRUCTION            ->	INSTRUCTIONS
                        |	.

INSTRUCTION             ->	AFFECTATION ;
                        |	APPEL_FONCTION ;
                        |	RETURN ;
                        |	BOUCLE
                        |	INPUT_OUTPUT
                        |	FONCTION
                        |	CONTROLE
                        |	VAR_DECLARATION ; .

AFFECTATION             ->	id Fid .

Fid                     ->	:= EXPRESSION ;
                        |	= EXPRESSION ;
                        |	<- EXPRESSION ; .

EXPRESSION              ->	TERM FTERM
                        |	( EXPRESSION ) .

FTERM                   ->	
                        |	+ EXPRESSION
                        |	- EXPRESSION .

TERM                    ->	FACTEUR FFACTEUR
                        |	+ FACTEUR
                        |	- FACTEUR .

FFACTEUR                ->	OPERATEURMULT FACTEUR
                        |	
                        |	OPERATEURSPECIAUX .

OPERATEURMULT           ->	*
                        |	mult
                        |	/
                        |	div
                        |	%
                        |	mod
                        |	modulo .

OPERATEURSPECIAUX       ->	++
                        |	-- .

FACTEUR                 ->	id
                        |	number
                        |	boolean
                        |	APPEL_FONCTION
                        |	string .

APPEL_FONCTION          ->	call id ( APPEL_FONCTION_ARG .

APPEL_FONCTION_ARG      ->	ARGUMENT )
                        |	) .

ARGUMENT                ->	id ARGUMENT1 .

ARGUMENT1               ->	, id ARGUMENT1
                        |	.

RETURN                  ->	return EXPRESSION .

BOUCLE                  ->	FORLOOP_STATEMENT
                        |	DOWHILELOOP_STATEMENT
                        |	WHILELOOP_STATEMENT .

FORLOOP_STATEMENT       ->	for Ffor .

Ffor                    ->	( F(
                        |	id Fid3 .

F(                      ->	VAR_DECLARATION FVAR_DECLARATION .
 
FVAR_DECLARATION        ->	; F;
                        |	: F:1 .

F;                      ->	CONDITIONS FCONDITIONS1 .

FCONDITIONS1            ->	; F;1 .
  
F;1                     ->	INSTRUCTION FINSTRUCTION1 .
  
FINSTRUCTION1           ->	) F)3 .
  
F)3                     ->	{ INSTRUCTIONS }
                        |	INSTRUCTION .
  
F:1           ->	id Fid4 .
                        
Fid4                    ->	) F)2 .

F)2                     ->	{ INSTRUCTIONS }
                        |	INSTRUCTION .

Fid3                    ->	in id { INSTRUCTIONS }
                        |	= number to number do INSTRUCTIONS ; .

WHILELOOP_STATEMENT     ->	while Fwhile .

Fwhile                  ->	( F(1 .

F(1                     ->	CONDITIONS FCONDITIONS .

FCONDITIONS             ->	) F) .

F)                      ->	INSTRUCTION
                        |	{ INSTRUCTIONS } .

DOWHILELOOP_STATEMENT   ->	do { INSTRUCTIONS } while ( CONDITIONS ) ;
                        |	repeat INSTRUCTIONS until CONDITIONS ; .

CONDITIONS              ->	CONDITION FCONDITION
                        |	! ( CONDITION )
                        |	not ( CONDITION ) .

FCONDITION              ->	&& CONDITIONS
                        |	|| CONDITIONS
                        |	and CONDITIONS
                        |	or CONDITIONS
                        |	.

CONDITION               ->	EXPRESSION comparator EXPRESSION .

INPUT_OUTPUT            ->	print ( ARGUMENT ) ;
                        |	printf ( ARGUMENT ) ;
                        |	scanf ( ARGUMENT ) ;
                        |	input ( ARGUMENT ) ;
                        |	log ( ARGUMENT ) ;
                        |	fprintf ( ARGUMENT ) ;
                        |	fscanf ( ARGUMENT ) ;
                        |	fread ( ARGUMENT ) ;
                        |	fwrite ( ARGUMENT ) ;
                        |	write ( ARGUMENT ) ;
                        |	read ( ARGUMENT ) ;
                        |	puts ( ARGUMENT ) ;
                        |	gets ( ARGUMENT ) ; .

FONCTION                ->	def type FONCTION2
                        |	function type FONCTION2 .

FONCTION2               ->	id ( PARAMETER ) { INSTRUCTIONS } .

PARAMETER               ->	id type PARAMETER1 .

PARAMETER1              ->	, id type PARAMETER1
                        |	.

CONTROLE                ->	IF
                        |	CASE
                        |	SHORTHAND .

IF                      ->	if Fif .


Fif                     ->	( F(2 .

F(2                     ->	CONDITION FCONDITION1 .

FCONDITION1             ->	) F)1 .

F)1                     ->	BLOCK_IF FBLOCK_IF .

FBLOCK_IF               ->	
                        |	else BLOCK_IF
                        |	elif BLOCK_IF else BLOCK_IF .

BLOCK_IF                ->	{ INSTRUCTIONS } .

CASE                    ->	switch ( EXPRESSION ) { BLOCK_CASE } .

BLOCK_CASE              ->	case Fcase
                        |	default : INSTRUCTIONS .

Fcase                   ->	FACTEUR FFACTEUR1 .

FFACTEUR1               ->	: F: .

F:                      ->	INSTRUCTIONS FINSTRUCTIONS .

FINSTRUCTIONS           ->	
                        |	BLOCK_CASE .

SHORTHAND               ->	( CONDITION ) ? INSTRUCTION : INSTRUCTION .

VAR_DECLARATION         ->	const TYPE IDS_CONST
                        |	let VARS'' .

VARS''                  ->	id Fid1 .

Fid1                    ->	VARS_TYPE FVARS_TYPE .

FVARS_TYPE              ->	symbole_aff Fsymbole_aff1
                        |	, VARS''
                        |	.

Fsymbole_aff1           ->	EXPRESSION FEXPRESSION1 .

FEXPRESSION1            ->	, VARS''
                        |	.

VARS_TYPE               ->	: type
                        |	is type .

IDS_CONST               ->	id Fid2 .

Fid2                    ->	symbole_aff Fsymbole_aff .

Fsymbole_aff            ->	EXPRESSION FEXPRESSION .


FEXPRESSION             ->	, IDS_CONST
                        |	.