
INSTRUCTIONS 			-> ACC_O INSTRUCTION INST'  ACC_F

INST'					-> INSTRUCTIONS | e

ACC_O 					-> accolade_ouverte | epsilon

ACC_F 					-> accolade_fermée | epsilon

INSTRUCTION             ->  AFFECTATION ;
                        |  APPEL_FONCTION ;
                        |  BOUCLE 
                        |  RETURN ;
                        |  VAR_DECLARATION ;
                        |  FONCTION 
                        |  CONTROLE 
                        |  EXCEPTION
                        |  FILEHANDLING 
                        


############################################# AFFECTATION #################
AFFECTATION             ->  const ID AFFECTATION'
                        | ID AFFECTATION'

AFFECTATION'            ->  SYMBOLE_AFF  EXPRESSION     
SYMBOLE_AFF             -> : EG | = | <-
EG 						-> = | .

EXPRESSION              ->   TERM EX'
EX'                     ->  OPERATEURADD TERM | .

VAR_DECLARATION         -> VARS' ; VAR_DECLARATION       
                        | .

VARS'                   -> const TYPE IDS_CONST 
                        | let JS_IDS  
						| VARS''              

VARS''                  -> ID VARS_TYPE OPT VARS''' 

VARS_TYPE 				-> : TYPE  
						| is TYPE

VARS'''					-> , VARS'' 
						| . 

IDS_CONST               -> ID AFFECTATION' IDS'


IDS'					-> , VARS'' 
						| .    

JS_IDS                  -> ID : TYPE OPT JS'
JS'						-> , JS_IDS | .

IDS                     -> ID OPT IDS''
IDS''					-> , IDS | .

OPT                     ->  AFFECTATION'
                        | .

ID                      ->   [a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?       //Terminal

######################################  CONTROL  ##############################

IF_STMT			   		-> if  COND  IF_STMT_SYMB INSTRUCTIONS  SUITE' END
						| SWITCH ( EXPRESSION ) INSTRUCTIONS END

SUITE' 					->  SUITE_IF  | .
IF_STMT_SYMB			->  : | .
			    	    
    		

COND     		->   ( STATEMENT ) | STATEMENT

SUITE_IF        -> 	ELIF_STMT | ELSE_BLOCK | .

ELIF_STMT		->  elif COND : INSTRUCTIONS ELIF_SUITE
ELIF_SUITE		-> 	ELIF_STMT | ELSE_BLOCK 

ELSE_BLOCK		->  else IF_STMT_SYMB INSTRUCTIONS 

SHORTHAND: 
    COND ? STATEMENT : STATEMENT

END: ';'
    | .


##############################LOOPS##############################

DOWHILELOOP_STATEMENT       ->  do accolade_ouverte STATEMENTS accolade_fermée while (CONDITION) ;
                            |   repeat STATEMENTS until CONDITION; 
                            |   .

FORLOOP_STATEMENT       ->  for A_F B_F
                        |   .

A_F 			-> (VAR_DECLARATION AF'
				| VAR_ID affectation NOMBRE to NOMBRE


AF'				->  ; CONDITION ; INSTRUCTION)  
				| (VAR_DECLARATION : ITERABLE) 

B_F 			->  B_F'
				| entree tab STATEMENTS
				| ITERATOR in ITERABLE :
				| do STATEMENTS ;

B_F'  			-> accolade_ouverte STATEMENTS accolade_fermée | STATEMENT

WHILELOOP_STATEMENT     ->  while A_W B_W

A_W    -> ( CONDITION )
		| CONDITION :

B_W    -> STATEMENT
		| accolade_ouvrante STATEMENTS accolade_fermante
		| entree tab STATEMENTS
		| do STATEMENTS ;

#########################   FONCTIONS  #########################

APPEL_FONCTION          -> ID ( PARAMETERS ) ;  // "ID ();" ???

FONCTION                ->  TYPE  FONCTION'
                        |   function FONCTION'

FONCTION'               -> ID(PARAMETERS) accolade_ouverte INSTS accolade_fermée;

PARAMETERS              -> PARAMETER
                        | epsilon 

PARAMETER               -> ID TYPE 
                        | PARAMETER , ID TYPE

#####################################################

OPERATEURSPECIAUX       ->  ++
                        | -- 
                    
OPERATEURADD            ->   + 
                        |  add
                        |  -
                        | minus 

 OPERATEURMULT          ->   *
                        |  mult 
                        |  \
                        |  div
                        |  % 
                        |  mod
                        |  modulo 

RETURN                  -> return EXPRESSION 

CONDITION               -> BOOLEAN 
                        | EXPRESSION COMPAR EXPRESSION

COMPAR                  ->  > 
                        | < 
                        | >=
                        | <=
                        | !=
                        | ==


##################     ###### ###### 
TYPE                    ->   string 
                        | number 
                        | int 
                        | boolean 
                        | bool 
                        | char  
                        | integer 
                        | boolean 
                        | void 
                        | float 
                        | double 
                        | signed
                        | unsigned
                        | short

ID                      ->   [a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?

STRING                  ->   guillemets STR guillemets 
                        |    ' STR ' 

STR                     ->   [ a-zA-Z0-9_;:!,?\|[](]&~^$µéè@à` ]* 
NUMBER                  ->   [0-9]+
BOOLEAN                 ->   true | false


FILEHANDLING            -> print ( PARAMETERS ) ;
                        | printf ( PARAMETERS ) ;
                        | scanf ( PARAMETERS ) ;
                        | print ( PARAMETERS ) ;
                        | input ( PARAMETERS ) ;
                        | log ( PARAMETERS )  ;
                        | fprintf ( PARAMETERS ) ; 
                        | fscanf ( PARAMETERS ) ;
                        | fread ( PARAMETERS ) ; 
                        | fwrite (  PARAMETERS ) ;
                        | write ( PARAMETERS ) ; 
                        | read (  PARAMETERS ) ;
                        | puts ( PARAMETERS ) ; 
                        | gets (  PARAMETERS ) ;



#############################TERMS##############
accolade_ouverte    -> {
accolade_fermée 	-> }
guillemets 			-> "